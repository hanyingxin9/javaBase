package javabase.oop;

/**
 * @description: Object Oriented Programming OOP 面向对象程序设计
 * @fileName: ObjectOrientedProgramming.java
 * @author: hanyingxin
 * @createAt: 2023/3/24 19:40
 * @updateBy: hanyingxin
 * @remark: Copyright
 */
public class ObjectOrientedProgramming {
    public static void main(String [] args){

        /*
          OOP : Object Oriented Programming 面向对象程序设计

                1. 类和对象 - 类以及类的成员（属性，方法，构造器，代码块，内部类）
                2. 面向对象的三大特征  封装 继承 多态
                3. 其他关键字  this super static abstract final interface package import ……


          高级编程语言分为两个阶段 :

             1. POP   Procedure Oriented Programming 面向过程程序设计
             2. OOP   Object Oriented Porgramming    面向对象程序设计


          面向对象三大特征 :

               1. 封装  Encapsulation
               2. 继承  Inheritance
               3. 多态  Polymorphism


          类（classs）
          对象（object）也被称作（instance）

          类的成员 :

            1. 属性 : 成员变量 域 字段 field
            2. 方法 : 成员方法 函数 method
            3. 构造器
            4. 代码块
            5. 内部类


          类和对象的使用（面向对象思想的落地实现）

            1. 创建类 ， 设计类的成员
            2. 利用类创建对象
            3. 通过 对象.属性 或者 对象.方法 调用对象的结构


          创建了一个类的多个对象 ， 则每个对象都独立的拥有了一套属于自己的类的实例属性 (非static)
          意味着如果我们修改一个对象的属性 a , 并不影响另一个对象的属性 a 的值


          对象的内存解析 :

             堆（Heap） :
                 唯一目的就是存放对象实例 ，几乎所有的对象实例以及数组都在堆中分配内存

             栈（Stack）:
                 虚拟机栈 用于存储局部变量 局部变量表存放了编译期可知长度的各种基本数据类型
                 (byte char short int long float double boolean) 以及对象引用(reference类型)
                 对象引用不等于对象本身 ， 是对象在堆内存的首地址 ， 方法执行完自动释放

             方法区（Method Area）:
                 用于存储已被虚拟机加载的类信息 ， 常量 ， 静态变量 ， 即时编译器编译后的代码等数据


内存结构


                       编译
           .java文件  ------->  .class文件  ------>  类装载器
                                                    -   -
                                                    -   -
                                                    -   -
                                                    -   -
内存区域                                              -   -

    方法区(Method Area)      虚拟机栈(VM Stack)          本地方法栈(Native Method Stack)

                                                                         ---->  垃圾收集器（gc）
    堆(Heap)                程序计数器(Program Couter Register)

     -   -                   -   -
     -   -                   -   -
     -   -                   -   -
     -   -                   -   -

     执行引擎  ----------->   本地库接口  -----------> 本地方法库




             类中成员   --->  UserTest

               属性（成员变量）   or    局部变量

               相同点 :
                  1. 定义变量的格式 :
                       数据类型 变量名 = 变量值
                      （成员变量即属性有默认值可以不在声明时直接写明变量值，局部变量没有默认值）
                  2. 先声明 ， 再使用
                  3. 变量都有其对应的作用域 {}

               不同点 :
                  1. 在类中声明的位置不同
                  成员变量属性直接声明在类的 {}中 ，
                  而局部变量声明在方法中，方法的形参，代码块中，构造器中，构造器形参

                  2. 权限修饰符
                  成员变量属性可以指明它的权限修饰符（public protected default private）
                  局部变量不可以使用权限修饰符修饰

                  3. 默认初始化值
                  成员变量属性都有默认初始化值
                  整形(byte short int long) : 0
                  浮点型(float double) : 0.0
                  字符型(char) : 0(ASCII码) or '\u0000'
                  布尔类型(boolean) : false
                  引用数据类型(类[字符串……] 接口 数组) : null

                  而局部变量则没有初始化值，所以要显式的赋值
                  特别的，形参调用的时候由实参给赋值

                  4. 在内存加载位置 :
                  成员变量属性(非static) : 加载到堆空间中 , static静态变量跟随类信息加载在方法区中
                  局部变量 : 加载在栈空间中



               类中成员 : 方法

                   方法的声明 :

                      权限修饰符 返回值类型 方法名(形参列表){

                      }

                      其中权限修饰符后面可以跟着 static(静态的) ，final(最终的) ， abstract(抽象的)来修饰的方法


                 权限修饰符 :
                     4种权限修饰符 :  public protected default private

                 返回值类型 :
                     有返回值 : 在方法声明时，指定返回值的类型 。
                     同时需要在方法中需要使用return关键字来返回指定类型的变量

                     没有返回值 : 方法声明时 ，使用void来表示
                     通常没有返回值的方法中不需要使用return ， 但是如果使用的话直接使用 return; 表示结束此方法

                 方法名 : 标识符 ， 见名知意

                 形参列表 :  方法可以声明 0个 1个 或者多个形参
                 格式 : 数据类型1 形参1 , 数据类型2 形参2

                 方法体 : 方法功能的体现


                 return关键字的使用 :
                  1. 使用范围 : 使用在方法体中
                  2. 作用 :
                       1. 结束方法 return;
                       2. 针对有返回值类型的方法 ， 使用 return 数据; 返回数据
                  3. return关键字后面不可以声明执行语句


                 方法中可以调用当前类的属性和方法
                 特殊的 : 方法A又调用了方法A : 递归调用
                 递归调用一定要慎重，要有结束条件不然就会变成死循环，
                 然后导致栈中的局部变量太多，造成栈溢出错误 java.lang.StackOverflowError

                 方法中不能定义方法

                 People.java内存解析
                 CircleTest.java计算圆面积练习
                 RectangleTest.java打印 * 矩形并计算矩形的面积
             *** StudentTest.java 对象数组的创建 赋值 遍历 冒泡排序 （对象结合数组的操作）


             编译完源程序以后 ， 生成一个或多个字节码文件
             我们使用 JVM中的类的加载器和解释器对生成的字节码文件进行解释运行
             意味着需要将字节码文件对应的类加载到内存中 ， 涉及到内存解析


回顾 : 变量的分类方式


      一.  根据数据类型分类 :

              1.八种基本数据类型 :
                  byte,char,short -> int -> long -> float -> double 以及 boolean类型

              2.引用数据类型 :
                  类（包括String字符串） 接口 数组


      二.  根据变量声明位置分类 :

              1.成员变量属性 :
                  1. 实例变量          （不以static修饰）
                  2. 类变量（静态变量）  （以static修饰）

              2.局部变量 :
                  1. 形参（方法 ， 构造器的形参）
                  2. 方法内局部变量（方法内，构造器内变量）
                  3. 代码块局部变量（在代码块内部定义）



       万事万物皆对象 :

         1. ***** 在java语言范畴中 ， 我们将功能、结构等封装到类中 ， 通过类的实例化来调用具体的功能结构
         2. 涉及到java语言与前端html、后端数据库交互时 ，前后端的结构在java层面交互时都体现为对象
            以数据库中的表为例 : 类对应数据表 类中属性对应表中字段 类创建的对象就是表中一条数据


       对象数组的内存解析 见截屏图片

       匿名对象的使用  AnonymousObject.java
          理解 : 我们创建的对象 ， 没有显示的赋给一个变量名 ，即为匿名对象
          特征 : 匿名对象只能使用一次
          使用 : 把匿名对象当成实数传递给另一个类方法的形参调用

       自定义数组的工具类 : 将数组中常见操作封装成一个工具类，需要用时直接创建类的对象调用方法即可


       方法的一些内容 :

           1. 方法的重载
           2. 可变形参的方法
           3. 方法参数和值传递机制
           4. 递归方法


       方法的重载（overload） -------->   OverLoadTest.java
         定义 :  在同一个类中 ， 允许存在一个以上的同名方法 ， 只要他们的参数个数或者参数类型不同即可
                比如 ， Arrays工具类中重载的sort() / binarySearch()方法


                "两同一不同" : 方法是否构成重载取决于以下几点要求 :
                    1. 同一个类 ， 同一个方法名
                    2. 参数列表不同（参数个数不同 ， 参数类型不同 ， 参数顺序不同）


          判断是否是重载方法 ，跟方法的权限修饰符 返回值类型 形参变量名 方法体没有关系 ， 只与参数列表有关系

          调用重载方法时传入的参数是两个int值，如果存在这个方法，参数是两个int值的情况就直接调用这个方法，
          如果不存在这个方法，存在同名方法参数是两个double形的也可以使用这个方法，这就是重载方法中的自动类型提升

          通过对象调用方法，如何确定某一个指定的方法 :
              1. 方法名
              2. 参数列表



          可变个数的形参 :   jdk5.0新增内容   -----> OverLoadTest.java

             格式 : 数据类型 ...变量名
             当调用可变个数的形参的方法时 ， 传入的参数个数可以是 0个 1个 2个 ...
             可变个数的形参的方法与本类中方法同名时 ， 形参不同的方法之间构成重载
             可变个数的形参的方法与本类中方法名相同，形参类型也相同的数组不构成重载，两种方式其实是同一个方法
             可变个数的形参的方法内部使用起来和数组使用方法一样
             可变个数的形参在方法的形参中必须声明在末尾
             可变个数的形参在方法的形参中 ， 最多只能声明一个可变形参



          *** 方法参数的值传递机制 :   ValueTransferTest.java

             关于变量的赋值 :

                 1. 如果变量是基本数据类型 ， 此时赋值的是变量所保存的数据值
                 2. 如果变量是引用数据类型 ， 此时赋值的是变量所保存的数据的地址值

             对于形参的值传递机制和上面是一样的 ， 向方法形参传递的实参如果是基本数据类型
             那么方法中的操作并不会改变实参的值 ， 这里经常出现错误 ， 向方法的形参传递基本数据类型
             导致根本就改变不了实参 ， 方法执行没有意义.

             如果参数是引用数据类型 ， 此时实参赋给形参的是存储数据的地址值 ， 这样一来
             形参和实参都指向了堆空间的同一实体 ， 方法中对形参的改变就会影响到真实的实参


             一句话总结 :
                 实参是基本数据类型 ，赋给形参就不会改变真实的实参
                 实参是引用数据类型 ，赋给形参的就是地址值，就会影响到实参 ，真正的实现方法调用


              **** 值传递机制的内存解析
                     把握栈存储局部变量 堆存储 new出来的实体 值传递机制


             -----------------------------------------------------

              int [] arr = new int[]{1,4,7};
              System.out.println(arr);
              ->[I@12b34 地址值

              char [] ch = new char[]{'a','b','c'};
              System.out.println(ch);
              ->abc 数组中元素值

              因为输出 int数组时调用的是 println(Object obj)方法
              输出 char数组时调用的是 println(char [])方法
              不同的重载方法 ， 输出char字符数组的println()方法中遍历了数组

              ------------------------------------------------------


          递归（recursion）方法 : 方法体内调用自己   -----> RecursionTest.java
            递归一定要向已知方向递归 ， 否则这种递归就变成了无穷递归 ， 类似于死循环


          ****

          关于值传递机制 ， 不要想当然认为向方法中传递基本数据类型参数就没有用 ， 传递引用类型参数
          就有用 ， 这是一种错误的想法 。
          以 String字符串为例 ，String字符串是引用类型 ， 传入方法中改变 String字符串应该是有效果的
          但是 String字符串底层是 char类型的数组 ， 是无法更改的 ， 所以做出的改变其实是指向了方法区常量池
          中的一个新的字符串 ， 所以实参 String字符串并没有改变 。 所以不要简单的认为值传递机制传递引用数据类型
          就一定会改变实参。（String字符串特殊一点）

          值传递机制以下这句话是绝对正确的 :

              如果参数是基本数据类型 ， 此时实参赋值给形参的是实参真实存储的数据值 。
              如果参数是引用数据类型 ， 此时实参赋值给形参的是实参存储数据的地址值 。

          ****


          递归调用中有重复计算很多次相同的值 ， 相同的值利用map存储起来可以有效降低重复计算的次数
          提高递归算法的执行效率 ， 降低时间复杂度 。




   封装


       高内聚 ， 低耦合

          高内聚 : 类的内部数据操作细节自己完成 ， 不允许外界干涉
          低耦合 : 仅对外暴露少量的方法用于使用

       当我们创建一个类的对象之后 ， 我们可以通过 "对象.属性"的方式 ， 对对象的属性进行赋值
       赋值的时候要受到属性数据类型和存储范围制约 ， 但是除此之外没有其他的制约条件
       但是在实际问题中 ，我们往往需要给属性赋值时加入额外的限制条件 ，这个条件不能在属性声明时
       体现 ， 只能通过方法进行限制条件的添加（比如 : setXXX(XXX xxx)）
       同时避免用户直接使用 “对象.属性”的方式对属性进行赋值 ， 需要将属性声明为私有（private）
       此时对于属性来说已经体现了对它的封装

       封装性的体现 :

          将类的属性私有（private）, 同时提供公共的（public）的方法来
          获取属性的值（getXXX）以及设置属性的值（setXXX）

          封装性的体现的扩展 :
              类中设置 private方法不对外暴露仅供类中方法调用
              单例模式


       权限修饰符 : 封装性的体现 ，需要权限修饰符来配合

       java规定的四种权限修饰符 : （权限从小到大）
           private default（缺省） protected public



权限修饰符作用范围

修饰符            类内部        同一个包        不同包的子类        同一个工程
private          ok
default（缺省）    ok           ok
protected        ok           ok              ok
public           ok           ok              ok                ok


       权限修饰符可以用来修饰类和类的内部结构（属性 ， 方法  ，构造器 ， 内部类）

       四种权限修饰符都可以修饰类的内部结构（属性 ， 方法 ， 构造器 ， 内部类） ， *** 注意代码块不行
       但是只有 default（缺省）和 public 才能修饰类 :
            class Person{}
            public class Person{}


       public（公开的） 在同一个工程下面都可以随便调用
       protected（受保护的）允许有继承关系的子类跨包调用父类
       default（缺省的）允许在同一个包下随便调用
       private（私有的）只允许在定义它的类的内部使用


       总结 :  java提供了 4种权限修饰符来修饰类以及类的内部结构  ，体现类以及类的内部结构在被调用时的可见性大小


       封装性就是隐藏对象内部的复杂性 ， 只对外公开简单的接口 ， 便于外界调用
       从而提高系统的可扩展性 ， 可维护性
       通俗一点说就是把该隐藏起来的隐藏起来 ， 把该暴露的暴露出来 ， 这就是封装性的设计思想 。

       在一个方法中 ， 如果对形参有条件判断 ， 如果符合条件可以在 if语句中直接 return;
       这样符合 if语句的形参直接被剔除掉 。 不符合剔除条件的直接可以执行下面语句
       例 :
                 public void setAge(int age){

                     if(age < 0 || age > 130){
                          //throw new RuntimeException("传入数据非法");
                          return;
                     }
                     this.age = age;
                 }

        注意 get/set方法不要合成一个方法 ， 每个方法只做一件事  ， 不要合成一个




    构造器（构造方法 ， constructor）  ------>  Constructor.java

        例 :  Person person = new Person();  //其中 new + Person(); Person()就是构造器

        构造器就是用来创建对象的

        1. 如果没有显式的定义类的构造器得话 ， 系统默认提供一个空参的构造器
        2. 定义构造器的格式 : 权限修饰符 类名(形参列表){}
        3. 一个类中定义的多个构造器 ， 彼此构成重载
        4. 一但我们显式的定义了类的构造器之后 ， 系统就不再提供默认的空参构造器
        5. 一个类中至少有一个构造器 ， 有构造器了才能去造对象


        构造器的作用 :
           1. 创建对象
           2. 初始化对象的信息


        剖析属性赋值过程 :

           目前有四种属性赋值方式 :  1，2，3只执行一次 ， 4可以反复执行
              1. 默认初始化
              2. 显式初始化
              3. 构造器初始化
              4. 通过 "对象.属性" or "对象.方法" 赋值


        JavaBean :

           java语言写成的可重用组件

           JavaBean是符合如下标准的Java类 :    -----> Customer.java
              1. 类是公共的
              2. 有一个无参的公共的构造器
              3. 私有属性 ， 向外提供对应的get/set方法

           之所以JavaBean需要提供一个空参的构造器是因为使用框架后不使用 new对象的方式创建对象了
           而是使用注入的方式 ， 也就是会使用反射的相关机制 ， 而反射创建对象需要借助空参构造器


        构造器的默认权限跟着类的权限走 ， 类只有 default（缺省）和 public（公开的 ）两种权限
        所以构造器也只有两种权限并且和类一致


        UML类图 :

           包名

                                     类名
                   -属性名 :  属性类型
                   +构造器名（需要初始化的属性 : 属性数据类型）  构造器带下划线
                   +方法名（参数名 : 参数类型）: 返回值类型

            + 代表 public类型
            - 代表 private类型
            # 代表 protected类型





         */
    }
}