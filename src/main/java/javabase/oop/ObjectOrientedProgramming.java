package javabase.oop;

/**
 * @description: Object Oriented Programming OOP 面向对象程序设计
 * @fileName: ObjectOrientedProgramming.java
 * @author: hanyingxin
 * @createAt: 2023/3/24 19:40
 * @updateBy: hanyingxin
 * @remark: Copyright
 */
public class ObjectOrientedProgramming {
    public static void main(String [] args){

        /*
          OOP : Object Oriented Programming 面向对象程序设计

                1. 类和对象 - 类以及类的成员（属性，方法，构造器，代码块，内部类）
                2. 面向对象的三大特征  封装 继承 多态
                3. 其他关键字  this super static abstract final interface package import ……


          高级编程语言分为两个阶段 :

             1. POP   Procedure Oriented Programming 面向过程程序设计
             2. OOP   Object Oriented Porgramming    面向对象程序设计


          面向对象三大特征 :

               1. 封装  Encapsulation
               2. 继承  Inheritance
               3. 多态  Polymorphism


          类（classs）
          对象（object）也被称作（instance）

          类的成员 :

            1. 属性 : 成员变量 域 字段 field
            2. 方法 : 成员方法 函数 method
            3. 构造器
            4. 代码块
            5. 内部类


          类和对象的使用（面向对象思想的落地实现）

            1. 创建类 ， 设计类的成员
            2. 利用类创建对象
            3. 通过 对象.属性 或者 对象.方法 调用对象的结构


          创建了一个类的多个对象 ， 则每个对象都独立的拥有了一套属于自己的类的实例属性 (非static)
          意味着如果我们修改一个对象的属性 a , 并不影响另一个对象的属性 a 的值


          对象的内存解析 :

             堆（Heap） :
                 唯一目的就是存放对象实例 ，几乎所有的对象实例以及数组都在堆中分配内存

             栈（Stack）:
                 虚拟机栈 用于存储局部变量 局部变量表存放了编译期可知长度的各种基本数据类型
                 (byte char short int long float double boolean) 以及对象引用(reference类型)
                 对象引用不等于对象本身 ， 是对象在堆内存的首地址 ， 方法执行完自动释放

             方法区（Method Area）:
                 用于存储已被虚拟机加载的类信息 ， 常量 ， 静态变量 ， 即时编译器编译后的代码等数据


内存结构


                       编译
           .java文件  ------->  .class文件  ------>  类装载器
                                                    -   -
                                                    -   -
                                                    -   -
                                                    -   -
内存区域                                              -   -

    方法区(Method Area)      虚拟机栈(VM Stack)          本地方法栈(Native Method Stack)

                                                                         ---->  垃圾收集器（gc）
    堆(Heap)                程序计数器(Program Couter Register)

     -   -                   -   -
     -   -                   -   -
     -   -                   -   -
     -   -                   -   -

     执行引擎  ----------->   本地库接口  -----------> 本地方法库




             类中成员   --->  UserTest

               属性（成员变量）   or    局部变量

               相同点 :
                  1. 定义变量的格式 :
                       数据类型 变量名 = 变量值
                      （成员变量即属性有默认值可以不在声明时直接写明变量值，局部变量没有默认值）
                  2. 先声明 ， 再使用
                  3. 变量都有其对应的作用域 {}

               不同点 :
                  1. 在类中声明的位置不同
                  成员变量属性直接声明在类的 {}中 ，
                  而局部变量声明在方法中，方法的形参，代码块中，构造器中，构造器形参

                  2. 权限修饰符
                  成员变量属性可以指明它的权限修饰符（public protected default private）
                  局部变量不可以使用权限修饰符修饰

                  3. 默认初始化值
                  成员变量属性都有默认初始化值
                  整形(byte short int long) : 0
                  浮点型(float double) : 0.0
                  字符型(char) : 0(ASCII码) or '\u0000'
                  布尔类型(boolean) : false
                  引用数据类型(类[字符串……] 接口 数组) : null

                  而局部变量则没有初始化值，所以要显式的赋值
                  特别的，形参调用的时候由实参给赋值

                  4. 在内存加载位置 :
                  成员变量属性(非static) : 加载到堆空间中 , static静态变量跟随类信息加载在方法区中
                  局部变量 : 加载在栈空间中



               类中成员 : 方法

                   方法的声明 :

                      权限修饰符 返回值类型 方法名(形参列表){

                      }

                      其中权限修饰符后面可以跟着 static(静态的) ，final(最终的) ， abstract(抽象的)来修饰的方法


                 权限修饰符 :
                     4种权限修饰符 :  public protected default private

                 返回值类型 :
                     有返回值 : 在方法声明时，指定返回值的类型 。
                     同时需要在方法中需要使用return关键字来返回指定类型的变量

                     没有返回值 : 方法声明时 ，使用void来表示
                     通常没有返回值的方法中不需要使用return ， 但是如果使用的话直接使用 return; 表示结束此方法

                 方法名 : 标识符 ， 见名知意

                 形参列表 :  方法可以声明 0个 1个 或者多个形参
                 格式 : 数据类型1 形参1 , 数据类型2 形参2

                 方法体 : 方法功能的体现


                 return关键字的使用 :
                  1. 使用范围 : 使用在方法体中
                  2. 作用 :
                       1. 结束方法 return;
                       2. 针对有返回值类型的方法 ， 使用 return 数据; 返回数据
                  3. return关键字后面不可以声明执行语句


                 方法中可以调用当前类的属性和方法
                 特殊的 : 方法A又调用了方法A : 递归调用
                 递归调用一定要慎重，要有结束条件不然就会变成死循环，
                 然后导致栈中的局部变量太多，造成栈溢出错误 java.lang.StackOverflowError

                 方法中不能定义方法

                 People.java内存解析
                 CircleTest.java计算圆面积练习
                 RectangleTest.java打印 * 矩形并计算矩形的面积
             *** StudentTest.java 对象数组的创建 赋值 遍历 冒泡排序 （对象结合数组的操作）


             编译完源程序以后 ， 生成一个或多个字节码文件
             我们使用 JVM中的类的加载器和解释器对生成的字节码文件进行解释运行
             意味着需要将字节码文件对应的类加载到内存中 ， 涉及到内存解析


回顾 : 变量的分类方式


      一.  根据数据类型分类 :

              1.八种基本数据类型 :
                  byte,char,short -> int -> long -> float -> double 以及 boolean类型

              2.引用数据类型 :
                  类（包括String字符串） 接口 数组


      二.  根据变量声明位置分类 :

              1.成员变量属性 :
                  1. 实例变量          （不以static修饰）
                  2. 类变量（静态变量）  （以static修饰）

              2.局部变量 :
                  1. 形参（方法 ， 构造器的形参）
                  2. 方法内局部变量（方法内，构造器内变量）
                  3. 代码块局部变量（在代码块内部定义）



       万事万物皆对象 :

         1. ***** 在java语言范畴中 ， 我们将功能、结构等封装到类中 ， 通过类的实例化来调用具体的功能结构
         2. 涉及到java语言与前端html、后端数据库交互时 ，前后端的结构在java层面交互时都体现为对象
            以数据库中的表为例 : 类对应数据表 类中属性对应表中字段 类创建的对象就是表中一条数据


       对象数组的内存解析 见截屏图片

       匿名对象的使用  AnonymousObject.java
          理解 : 我们创建的对象 ， 没有显示的赋给一个变量名 ，即为匿名对象
          特征 : 匿名对象只能使用一次
          使用 : 把匿名对象当成实数传递给另一个类方法的形参调用

       自定义数组的工具类 : 将数组中常见操作封装成一个工具类，需要用时直接创建类的对象调用方法即可


       方法的一些内容 :

           1. 方法的重载
           2. 可变形参的方法
           3. 方法参数和值传递机制
           4. 递归方法


       方法的重载（overload） -------->   OverLoadTest.java
         定义 :  在同一个类中 ， 允许存在一个以上的同名方法 ， 只要他们的参数个数或者参数类型不同即可
                比如 ， Arrays工具类中重载的sort() / binarySearch()方法


                "两同一不同" : 方法是否构成重载取决于以下几点要求 :
                    1. 同一个类 ， 同一个方法名
                    2. 参数列表不同（参数个数不同 ， 参数类型不同 ， 参数顺序不同）


          判断是否是重载方法 ，跟方法的权限修饰符 返回值类型 形参变量名 方法体没有关系 ， 只与参数列表有关系

          调用重载方法时传入的参数是两个int值，如果存在这个方法，参数是两个int值的情况就直接调用这个方法，
          如果不存在这个方法，存在同名方法参数是两个double形的也可以使用这个方法，这就是重载方法中的自动类型提升

          通过对象调用方法，如何确定某一个指定的方法 :
              1. 方法名
              2. 参数列表



          可变个数的形参 :   jdk5.0新增内容   -----> OverLoadTest.java

             格式 : 数据类型 ...变量名
             当调用可变个数的形参的方法时 ， 传入的参数个数可以是 0个 1个 2个 ...
             可变个数的形参的方法与本类中方法同名时 ， 形参不同的方法之间构成重载
             可变个数的形参的方法与本类中方法名相同，形参类型也相同的数组不构成重载，两种方式其实是同一个方法
             可变个数的形参的方法内部使用起来和数组使用方法一样
             可变个数的形参在方法的形参中必须声明在末尾
             可变个数的形参在方法的形参中 ， 最多只能声明一个可变形参



          *** 方法参数的值传递机制 :   ValueTransferTest.java

             关于变量的赋值 :

                 1. 如果变量是基本数据类型 ， 此时赋值的是变量所保存的数据值
                 2. 如果变量是引用数据类型 ， 此时赋值的是变量所保存的数据的地址值

             对于形参的值传递机制和上面是一样的 ， 向方法形参传递的实参如果是基本数据类型
             那么方法中的操作并不会改变实参的值 ， 这里经常出现错误 ， 向方法的形参传递基本数据类型
             导致根本就改变不了实参 ， 方法执行没有意义.

             如果参数是引用数据类型 ， 此时实参赋给形参的是存储数据的地址值 ， 这样一来
             形参和实参都指向了堆空间的同一实体 ， 方法中对形参的改变就会影响到真实的实参


             一句话总结 :
                 实参是基本数据类型 ，赋给形参就不会改变真实的实参
                 实参是引用数据类型 ，赋给形参的就是地址值，就会影响到实参 ，真正的实现方法调用


              **** 值传递机制的内存解析
                     把握栈存储局部变量 堆存储 new出来的实体 值传递机制


             -----------------------------------------------------

              int [] arr = new int[]{1,4,7};
              System.out.println(arr);
              ->[I@12b34 地址值

              char [] ch = new char[]{'a','b','c'};
              System.out.println(ch);
              ->abc 数组中元素值

              因为输出 int数组时调用的是 println(Object obj)方法
              输出 char数组时调用的是 println(char [])方法
              不同的重载方法 ， 输出char字符数组的println()方法中遍历了数组

              ------------------------------------------------------



          递归（recursion）方法 : 方法体内调用自己

            递归一定要向已知方向递归 ， 否则这种递归就变成了无穷递归 ， 类似于死循环








































         */
    }
}
